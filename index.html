<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ShimeChamhoc ‚Äì Full Features</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
  <script>
    function sanitizeHTML(input) {
  const html = String(input ?? "");
  const doc = new DOMParser().parseFromString(html, "text/html");

  // Remove dangerous tags entirely
  doc.querySelectorAll(
    "script, style, iframe, object, embed, link, meta, base, form"
  ).forEach(el => el.remove());

  // Allowlist for <img> hosts (optional). Empty => allow any https host.
  const ALLOWED_IMG_HOSTS = new Set([
    // "i.imgur.com",
    // "images.unsplash.com",
    // "raw.githubusercontent.com",
  ]);

  const isSafeUrl = (url, { allowDataImage = false, allowHttp = false } = {}) => {
    const v = String(url || "").trim();
    if (!v) return true;

    const lower = v.toLowerCase();

    // allow same-origin / relative URLs
    if (lower.startsWith("#") || lower.startsWith("/") || lower.startsWith("./") || lower.startsWith("../")) return true;

    // allow mailto
    if (lower.startsWith("mailto:")) return true;

    // allow data:image/*;base64,...
    if (allowDataImage && lower.startsWith("data:image/")) {
      // basic validation: must include ;base64,
      return lower.includes(";base64,");
    }

    // block dangerous schemes
    if (
      lower.startsWith("javascript:") ||
      lower.startsWith("vbscript:") ||
      lower.startsWith("file:") ||
      lower.startsWith("blob:") ||
      lower.startsWith("data:")
    ) return false;

    // allow http/https (prefer https)
    if (lower.startsWith("https://") || (allowHttp && lower.startsWith("http://"))) {
      try {
        const u = new URL(v);
        if (ALLOWED_IMG_HOSTS.size === 0) return true;
        return ALLOWED_IMG_HOSTS.has(u.host);
      } catch {
        return false;
      }
    }
    return false;
  };

  doc.querySelectorAll("*").forEach(el => {
    const tag = el.tagName.toLowerCase();

    // Strip all inline event handlers + style
    [...el.attributes].forEach(attr => {
      const name = attr.name.toLowerCase();
      const value = String(attr.value || "").trim();

      if (name.startsWith("on")) {
        el.removeAttribute(attr.name);
        return;
      }
      if (name === "style") {
        el.removeAttribute(attr.name);
        return;
      }

      if (name === "href") {
        if (!isSafeUrl(value)) el.removeAttribute(attr.name);
        return;
      }

      if (name === "src") {
        if (tag === "img") {
          // allow base64 images OR https URLs (optional allowlist by host)
          if (!isSafeUrl(value, { allowDataImage: true, allowHttp: false })) {
            el.removeAttribute(attr.name);
          }
        } else {
          if (!isSafeUrl(value)) el.removeAttribute(attr.name);
        }
        return;
      }

      // Remove potentially risky attributes on non-img tags
      if (tag !== "img") {
        if (name === "srcset") el.removeAttribute(attr.name);
      }
    });

    // For <img>, keep only a small allowlist of attributes
    if (tag === "img") {
      const allowed = new Set(["src", "alt", "title", "width", "height", "loading", "decoding"]);
      [...el.attributes].forEach(attr => {
        if (!allowed.has(attr.name.toLowerCase())) el.removeAttribute(attr.name);
      });
      if (!el.getAttribute("loading")) el.setAttribute("loading", "lazy");
      if (!el.getAttribute("decoding")) el.setAttribute("decoding", "async");
    }
  });

  return doc.body.innerHTML;
}

let searchKeywordN = ''; // ‚úÖ keyword ƒë√£ strip s·∫µn
    let currentQuizIndex = 0;
let searchKeyword = '';
    let isSubmitted = false;
let qCells = [];      // l∆∞u DOM c·ªßa t·ª´ng √¥ theo index
let mapBuilt = false; // ƒë√£ build map ch∆∞a
let currentCellIndex = -1;
window.MathJax = {
  tex: { inlineMath: [['\\(','\\)'], ['$', '$']] }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /* Transition c√≥ ki·ªÉm so√°t ƒë·ªÉ kh√¥ng l√†m MathJax/layout b·ªã nh√°y */
.btn,
.choice,
.bookmark-btn,
.qcell {
  transition: transform .2s ease,
              background-color .2s ease,
              border-color .2s ease,
              color .2s ease,
              box-shadow .2s ease,
              opacity .2s ease;
}

/* Ch·∫∑n transition b√™n trong MathJax ƒë·ªÉ kh·ªèi ‚Äúnh·∫•p nh√°y‚Äù khi ƒë·ªïi class */
.mjx-container, .mjx-container * {
  transition: none !important;
}
    :root { 
      --bg: #0b1220; --card: rgba(22, 32, 53, 0.8); --muted: #94a3b8; 
      --text: #f8fafc; --acc: #38bdf8; --ok: #22c55e; --bad: #ef4444; 
      --border: rgba(255, 255, 255, 0.08);
    }
    /* ===== LIGHT MODE ===== */
[data-theme="light"] {
  --bg: #f1f5f9;
  --card: rgba(255, 255, 255, 0.9);
  --muted: #475569;
  --text: #0f172a;
  --acc: #0284c7;
  --ok: #16a34a;
  --bad: #dc2626;
  --border: rgba(0, 0, 0, 0.08);
}
/* ===== FIX dropdown khi Light mode ===== */
[data-theme="light"] select,
[data-theme="light"] option {
  background: #ffffff;
  color: #0f172a;
  border-color: rgba(0, 0, 0, 0.15);
}

    * { box-sizing: border-box; }
    body {
  margin: 0;
  font-family: 'Inter', sans-serif;
  background: radial-gradient(circle at top right, var(--bg), #0b1220);
  color: var(--text);
  line-height: 1.6;
  min-height: 100vh;
}

    header {
      position: sticky; top: 0; z-index: 100;
      background: rgba(11, 18, 32, 0.7); backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
    }
    .wrap { max-width: 1100px; margin: auto; padding: 16px; }
    .row { display: grid; grid-template-columns: 320px 1fr; gap: 24px; }
    .card {
      background: var(--card); border: 1px solid var(--border);
      border-radius: 20px; box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      backdrop-filter: blur(10px);
    }
    .pad { padding: 24px; }
    .muted { color: var(--muted); font-size: 14px; }
    .btn {
      cursor: pointer; border: none; border-radius: 12px; padding: 12px 18px;
      font-weight: 600; background: #1b2a4a; color: #dbe7ff;
      display: inline-flex; align-items: center; gap: 8px;
    }
    .btn:hover { transform: translateY(-2px); background: #2a3d66; }
    .btn:disabled { opacity: 0.3; cursor: not-allowed; }
    .btn.secondary { background: #334155; color: #f1f5f9; }
    .btn.ok { background: #14532d; color: #bbf7d0; }
    .btn.warn { background: #7f1d1d; color: #fecaca; }
    .grid { display: grid; gap: 12px; }
   select#quizSelect {
  appearance: none;
  background-image:
    linear-gradient(45deg, transparent 50%, var(--muted) 50%),
    linear-gradient(135deg, var(--muted) 50%, transparent 50%);
  background-position:
    calc(100% - 18px) 55%,
    calc(100% - 12px) 55%;
  background-size: 6px 6px;
  background-repeat: no-repeat;
}
.choice input,
.choice label {
  pointer-events: none;
}

    .choice {
      border: 1px solid var(--border); border-radius: 14px; padding: 16px;
      cursor: pointer; background: rgba(255,255,255,0.03); display: flex; align-items: center;
    }
    .choice:hover { border-color: var(--acc); transform: translateX(4px); }
    .choice.active { outline: 2px solid var(--acc); background: rgba(56, 189, 248, 0.1); }
    .choice.correct { outline: 2px solid var(--ok); background: rgba(34, 197, 94, 0.15); }
    .choice.wrong { outline: 2px solid var(--bad); background: rgba(239, 68, 68, 0.15); }
    .pill { display: inline-block; padding: 4px 12px; border-radius: 8px; background: rgba(56, 189, 248, 0.1); color: var(--acc); font-size: 12px; font-weight: 600; }
    .timer { font-family: monospace; font-size: 18px; color: #fbbf24; }
    .progress { height: 10px; background: #111a2d; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; background: linear-gradient(90deg, var(--acc), #4ade80); transition: width 0.4s ease; }
    #sheepPopup {
      position: fixed; inset: 0; display: none; justify-content: center; align-items: center;
      background: rgba(0,0,0,0.7); backdrop-filter: blur(8px); z-index: 9999;
    }
    #sheepPopup .box{
      max-width: 240px;
  width: fit-content;
  pointer-events: auto;
  background: transparent;  
  border: none;
  box-shadow: none;
  padding: 10px 14px 6px;
  text-align: center;
  animation: stickerPop .35s cubic-bezier(.2,1.4,.4,1);
}
#sheepPopup img{
  width:150px;
  height:auto;
  display:block;
  margin:0 auto 6px;
  /* VI·ªÄN STICKER */
  filter:
    drop-shadow(0 0 0 6px white)
    drop-shadow(0 10px 22px rgba(0,0,0,0.35));

  transform: rotate(-4deg);
}
    #qText{
  max-height: 260px;
  overflow-y: auto;
  padding-right: 6px;
  word-break: break-word;
  line-height: 1.6;
}

@media (max-width: 960px) { 
  .row { grid-template-columns: 1fr; } 
}
@keyframes pop{
  0%   { transform: scale(0.7) rotate(-8deg); opacity: 0 }
  60%  { transform: scale(1.05) rotate(3deg); opacity: 1 }
  100% { transform: scale(1) rotate(0deg); }
}
@keyframes stickerPop{
  0% {
    transform: scale(0.3) rotate(-12deg);
    opacity: 0;
  }
  70% {
    transform: scale(1.08) rotate(3deg);
    opacity: 1;
  }
  100% {
    transform: scale(1) rotate(0deg);
  }
}
[data-theme="light"] select#quizSelect {
  background: #ffffff !important;
  color: #0f172a !important;
}
#fireworks {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9998;
}

#congratsText {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0.8);
  font-size: 2.2rem;
  font-weight: 800;
  color: var(--ok);
  opacity: 0;
  z-index: 9999;
  text-align: center;
  transition: all 0.4s ease;
}

#congratsText.show {
  opacity: 1;
  transform: translateX(-50%) scale(1);
}
#resultOverlay {
  position: fixed;
  inset: 0;
  background: rgba(11, 18, 32, 0.65);
  backdrop-filter: blur(6px);
  z-index: 9997;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s ease;
}

#resultOverlay.show {
  opacity: 1;
  pointer-events: auto;
}
.qcell {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  border: 2px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-weight: 600;
  position: relative;
}

.qcell.done { border-color: var(--acc); }
.qcell.correct { background: rgba(34,197,94,0.2); border-color: var(--ok); }
.qcell.wrong { background: rgba(239,68,68,0.2); border-color: var(--bad); }

.qcell.bookmark::after {
  content: "‚≠ê";
  position: absolute;
  font-size: 12px;
  top: -6px;
  right: -4px;
}

.bookmark-btn {
  cursor: pointer;
  font-size: 22px;
  user-select: none;
  transition: transform .2s ease, color .2s ease;
}
.bookmark-btn:hover {
  transform: scale(1.2);
}
.bookmark-btn.active {
  color: #facc15; /* v√†ng */
}
/* Gi·ªØ ch·ªó ƒë·ªÉ Next c√¢u kh√¥ng gi·∫≠t layout */
#qChoices { 
  min-height: 240px; /* c√≥ th·ªÉ ch·ªânh 200-320 t√πy ƒë·ªÅ */
}

/* Fade nh·∫π khi chuy·ªÉn c√¢u (ƒë·ª° nh√°y) */
#screenQuiz { 
  opacity: 1;
  transition: opacity .12s ease;
}
#screenQuiz.is-switching {
  opacity: 0;
}
  </style>
</head>
<body>
  <header>
    <div class="wrap" style="display:flex;align-items:center;justify-content:space-between;">
      <div style="font-weight:800;font-size:1.2rem; color: var(--acc)">üìò ShimeChamhoc</div>
      <button class="btn secondary" onclick="$('#fileInput').click()">N·∫°p JSON</button>
      <button class="btn secondary" onclick="openTextbookImporter()">üìÑ N·∫°p gi√°o tr√¨nh</button>

      <button class="btn ghost" id="toggleTheme">üåô / ‚òÄÔ∏è</button>

    </div>
  </header>

  <main class="wrap" style="margin-top:24px">
    <div class="row">
      <aside class="card pad">

        <h3>C√†i ƒë·∫∑t</h3>
        <div class="grid">
          <div class="grid muted" id="quizSelectGroup" style="display:none">
            <label>Ch·ªçn b·ªô ƒë·ªÅ</label>
            <select id="quizSelect"></select>
          </div>
          <div class="grid muted">
            <label>Th·ªùi gian (ph√∫t)</label>
            <input type="number" id="timeLimit" min="0" value="0" style="padding:10px; border-radius:8px; background:#0d1424; color:white; border:1px solid var(--border)"/>
          </div>
          <div style="display:flex;gap:10px" class="muted">
            <input type="checkbox" id="shuffle" checked /> <label for="shuffle">X√°o tr·ªôn ƒë·ªÅ</label>
          </div>
          <div style="display:flex;gap:10px" class="muted">
            <input type="checkbox" id="instant" checked /> <label for="instant">Ch·∫•m t·ª©c th√¨</label>
          </div>
          <div style="display:flex;gap:10px" class="muted">
            <input type="checkbox" id="autoNext" /> <label for="autoNext">T·ª± chuy·ªÉn c√¢u</label>
          </div>
          <button class="btn ok" id="btnStart" style="width:100%; margin-top:10px">B·∫Øt ƒë·∫ßu</button>
          <hr style="border:none;border-top:1px solid var(--border);margin:14px 0">

<div class="grid muted">
  <label>T·∫°o ƒë·ªÅ thi (tr·ªôn ch∆∞∆°ng)</label>

  <div style="display:flex; gap:10px; align-items:center">
    <span style="min-width:110px">S·ªë c√¢u</span>
    <input type="number" id="examCount" min="10" max="200" value="60"
      style="flex:1;padding:10px;border-radius:8px;background:#0d1424;color:white;border:1px solid var(--border)"/>
  </div>

  <div style="display:flex; gap:10px; align-items:center">
    <span style="min-width:110px">% Ch1</span>
    <input type="number" id="p1" min="0" max="100" value="10"
      style="flex:1;padding:10px;border-radius:8px;background:#0d1424;color:white;border:1px solid var(--border)"/>
  </div>

  <div style="display:flex; gap:10px; align-items:center">
    <span style="min-width:110px">% Ch2</span>
    <input type="number" id="p2" min="0" max="100" value="45"
      style="flex:1;padding:10px;border-radius:8px;background:#0d1424;color:white;border:1px solid var(--border)"/>
  </div>

  <div style="display:flex; gap:10px; align-items:center">
    <span style="min-width:110px">% Ch3</span>
    <input type="number" id="p3" min="0" max="100" value="45"
      style="flex:1;padding:10px;border-radius:8px;background:#0d1424;color:white;border:1px solid var(--border)"/>
  </div>

  <button class="btn secondary" id="btnMakeExam" style="width:100%">
    üìù T·∫°o ƒë·ªÅ thi
  </button>

  <div class="muted" id="examInfo" style="font-size:12px"></div>
</div>
        </div>
      </aside>

      <section class="card pad" id="panelMain">
        <div id="screenIntro">
          <h2 style="margin-top:0">S·∫µn s√†ng ch∆∞a?</h2>
          <p class="muted" id="statusMessage">ƒêang ch·ªù d·ªØ li·ªáu...</p>
          <input type="file" id="fileInput" accept="application/json" style="display:none" />
          <input type="file" id="textbookInput" accept=".txt,.md,.html,text/plain,text/markdown,text/html" style="display:none" />

        </div>

        <div id="screenQuiz" style="display:none">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
            <span class="pill" id="qIndex"></span>

            <div style="display:flex;align-items:center;gap:14px">
                <span id="bookmarkBtn" class="bookmark-btn">‚≠ê</span>
                <div class="timer pill" id="timer">--:--</div>
          </div>
          </div>

          <div id="qText" style="font-size:20px;font-weight:700;margin-bottom:24px;"></div>
          <div id="qChoices" class="grid"></div>
          <div style="display:flex;justify-content:space-between;margin-top:30px; border-top: 1px solid var(--border); padding-top:20px">
            <button class="btn secondary" id="btnPrev">‚Üê Tr∆∞·ªõc</button>
            <div style="display:flex; gap:10px">
              <button class="btn ok" id="btnNext">Ti·∫øp ‚Üí</button>
              <button class="btn warn" id="btnSubmit">N·ªôp b√†i</button>
            </div>
          </div>
          <div id="explain" class="muted" style="margin-top:15px; padding:12px; background:rgba(255,255,255,0.03); border-radius:10px"></div>
          <button class="btn secondary" id="btnAIExplain" style="margin-top:10px">
  ü§ñ Gi·∫£i th√≠ch b·∫±ng AI
          </button>
          <div id="questionMap" class="card pad" style="margin-top:20px">

          <div style="font-weight:700;margin-bottom:10px">üìã T·ªïng quan c√¢u h·ªèi</div>

  <!-- FILTER BUTTONS -->
          <div style="display:flex;gap:8px;margin-bottom:10px">
          <button class="btn secondary" id="filterAll">T·∫•t c·∫£</button>
          <button class="btn secondary" id="filterBookmark">‚≠ê Bookmark</button>
          <button class="btn secondary" id="filterWrong">‚ùå C√¢u sai</button>
          </div>
          <input id="searchBox" placeholder="T√¨m c√¢u h·ªèi..." 
            style="width:100%; padding:10px; border-radius:10px;
            background:rgba(255,255,255,0.03); color:var(--text);
            border:1px solid var(--border); margin-bottom:10px;">

           <div id="questionGrid"
       style="display:grid;grid-template-columns:repeat(auto-fill,40px);gap:8px">
  </div>
</div>

        </div>

        <div id="screenResult" style="display:none">
          <h2 style="color: var(--ok)">Ho√†n th√†nh!</h2>
          <p id="scoreLine" style="font-size: 1.5rem; font-weight: 800;"></p>
          <div class="progress" style="margin:20px 0"><div id="scoreBar"></div></div>
          <div style="display:flex; gap:10px; margin-bottom:20px">
            <button class="btn ok" onclick="location.reload()">L√†m ƒë·ªÅ kh√°c</button>
          </div>
          <div id="reviewArea"></div>
        </div>
      </section>
    </div>
  </main>

  <div id="sheepPopup">
    <div class="box">
      <img src="sheep.png" alt="Sheep sticker">
      <div style="font-weight:800">C·ªë g·∫Øng l√™nnn! üêë</div>
      <p class="muted">Sai 3 c√¢u r·ªìi ƒë√≥, b√¨nh tƒ©nh nh√©!</p>
      <button class="btn ok" onclick="$('#sheepPopup').style.display='none'; wrongStreak=0;">Ti·∫øp t·ª•c</button>
    </div>
  </div>


  <!-- ===== TEXTBOOK IMPORTER MODAL ===== -->
  <div id="importerModal" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.65);backdrop-filter:blur(6px);z-index:9996;">
    <div class="card pad" style="max-width:920px;width:min(920px,92vw);max-height:84vh;overflow:auto;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;">
        <div>
          <div style="font-weight:800;font-size:1.1rem">üìÑ Nh·∫≠p gi√°o tr√¨nh ‚Üí T·∫°o JSON</div>
          <div class="muted" style="margin-top:2px">H·ªó tr·ª£ nhanh: TXT/MD/HTML (copy/paste ho·∫∑c t·∫£i file). PDF scan c·∫ßn OCR (m√¨nh h∆∞·ªõng d·∫´n sau).</div>
        </div>
        <button class="btn secondary" onclick="closeTextbookImporter()">‚úñ</button>
      </div>

      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:14px">
        <button class="btn secondary" onclick="$('#textbookInput').click()">üìé Ch·ªçn file</button>
        <button class="btn secondary" onclick="importerPasteExample()">üß™ D√°n v√≠ d·ª•</button>
        <button class="btn ok" onclick="importerParse()">‚öôÔ∏è T·∫°o quiz JSON</button>
        <button class="btn secondary" id="btnDownloadGenerated" onclick="downloadGeneratedJSON()" disabled>‚¨áÔ∏è T·∫£i JSON</button>
      </div>

      <div class="grid" style="margin-top:12px">
        <label class="muted">N·ªôi dung gi√°o tr√¨nh (c√≥ th·ªÉ d√°n nguy√™n ch∆∞∆°ng + ƒë√°p √°n)</label>
        <textarea id="textbookArea" style="width:100%;min-height:220px;resize:vertical;padding:12px;border-radius:12px;background:rgba(255,255,255,0.03);color:var(--text);border:1px solid var(--border)"></textarea>

        <div style="display:flex;gap:14px;flex-wrap:wrap;align-items:center" class="muted">
          <label style="display:flex;gap:8px;align-items:center"><input type="checkbox" id="splitByChapter" checked> T√°ch theo ch∆∞∆°ng</label>
          <label style="display:flex;gap:8px;align-items:center"><input type="checkbox" id="keepAnswerInExplanation" checked> N·∫øu thi·∫øu ƒë√°p √°n ‚Üí nh√©t v√†o "gi·∫£i th√≠ch"</label>
          <label style="display:flex;gap:8px;align-items:center"><input type="checkbox" id="autoLoadAfterParse" checked> N·∫°p lu√¥n v√†o quiz sau khi t·∫°o</label>
        </div>

        <div id="importerReport" class="muted" style="padding:12px;border-radius:12px;background:rgba(255,255,255,0.03);border:1px solid var(--border)"></div>
      </div>
    </div>
  </div>

  <script>
    const $ = (sel)=>document.querySelector(sel);
    const $$ = (sel)=>Array.from(document.querySelectorAll(sel));
function fetchWithTimeout(url, options = {}, timeoutMs = 12000) {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  return fetch(url, { ...options, signal: ctrl.signal }).finally(() => clearTimeout(t));
}

    const strip = (s)=> (s??'').toString().trim().toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'');

    // ===== TEXTBOOK IMPORTER (TXT/MD/HTML -> JSON quiz) =====
    let __generatedQuizzes = null; // array of quizzes compatible with handleData()

    function openTextbookImporter() {
      $('#importerModal').style.display = 'flex';
      $('#importerReport').textContent = 'üëâ D√°n n·ªôi dung ho·∫∑c ch·ªçn file, r·ªìi b·∫•m "T·∫°o quiz JSON".';
    }
    function closeTextbookImporter() {
      $('#importerModal').style.display = 'none';
    }
    function importerPasteExample() {
      $('#textbookArea').value =
`CH∆Ø∆†NG 1: M·ªü ƒë·∫ßu
1) C√¢u 1 l√† g√¨?
A. ƒê√°p √°n A
B. ƒê√°p √°n B
C. ƒê√°p √°n C
D. ƒê√°p √°n D
ƒê√°p √°n: B
Gi·∫£i th√≠ch: V√¨ ...

2) C√¢u 2 ...
A) ...
B) ...
C) ...
D) ...
ƒê√°p √°n: A

CH∆Ø∆†NG 2: ...
1. C√¢u ...
A. ...
B. ...
C. ...
D. ...
ƒê√°p √°n: D`;
    }

    $('#textbookInput').onchange = (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      const r = new FileReader();
      r.onload = () => {
        $('#textbookArea').value = String(r.result || '');
        openTextbookImporter();
        $('#importerReport').textContent = `‚úÖ ƒê√£ n·∫°p file: ${f.name}. B·∫•m "T·∫°o quiz JSON".`;
      };
      r.readAsText(f, 'utf-8');
      e.target.value = '';
    };

    function normalizeLines(raw) {
      return String(raw || '')
        .replace(/\r\n/g, '\n')
        .replace(/\r/g, '\n')
        .replace(/\u00A0/g, ' ')
        .split('\n');
    }

    function parseTextbookToQuizzes(raw, opts = {}) {
  const {
    splitByChapter = true,
    keepAnswerInExplanation = true
  } = opts;

  const lines = normalizeLines(raw);

  const reChapter = /^\s*(?:ch(?:∆∞∆°|u)∆°ng|chapter)\s*([0-9]+)\s*[:\-.]?\s*(.*)$/i;
  const reQStart = /^\s*(\d{1,4})\s*[\)\.\:\-]\s*(.+)$/; // "1) ..." or "1. ..."
  const reChoice = /^\s*([A-D])\s*[\)\.\:\-]\s*(.+)$/i;
  const reAnswer = /^\s*(?:ƒë√°p\s*√°n|dap\s*an|ans(?:wer)?)\s*[:\-‚Äì=]*\s*([A-D](?:\s*(?:,|\/|v√†|and)\s*[A-D])*)\s*$/i;
  const reExplain = /^\s*(?:gi·∫£i\s*th√≠ch|giai\s*thich|explain(?:ation)?)\s*[:\-‚Äì=]*\s*(.*)$/i;

  function newQuiz(title) {
    return { title: title || 'B·ªô c√¢u h·ªèi', timeLimit: 0, questions: [] };
  }

  // -------------------------
  // PASS 1: scan questions/choices/explanations; answers may be missing
  // -------------------------
  let quizzes = [];
  let curQuiz = newQuiz('B·ªô c√¢u h·ªèi');
  let curQ = null;
  let pendingExplain = [];

  const idxMap = { A:0, B:1, C:2, D:3 };

  function normalizeAnswerRaw(rawAns) {
    const letters = String(rawAns || "")
      .toUpperCase()
      .split(/[,\/]|v√†|and/i)
      .map(s => s.trim())
      .filter(Boolean)
      .filter(s => /^[A-D]$/.test(s));
    if (!letters.length) return null;
    const arr = [...new Set(letters.map(l => idxMap[l]))].sort((a,b)=>a-b);
    return arr.length === 1 ? arr[0] : arr;
  }

  function flushQuestion() {
    if (!curQ) return;

    if (pendingExplain.length) {
      const exp = pendingExplain.join('\n').trim();
      if (exp) curQ.explanation = curQ.explanation ? (curQ.explanation + '\n' + exp) : exp;
      pendingExplain = [];
    }

    // minimal validation: must have text + >=2 choices
    if (!curQ.text || !Array.isArray(curQ.choices) || curQ.choices.length < 2) {
      curQ = null;
      return;
    }

    // keep raw answer if missing; DO NOT force answer=0 here
    if (curQ.answer == null && keepAnswerInExplanation && curQ._rawAnswer) {
      curQ.explanation = (curQ.explanation ? (curQ.explanation + '\n') : '') + `ƒê√°p √°n (th√¥): ${curQ._rawAnswer}`;
    }
    delete curQ._rawAnswer;

    curQuiz.questions.push(curQ);
    curQ = null;
  }

  function flushQuizIfHasQuestions() {
    flushQuestion();
    if (curQuiz.questions.length) quizzes.push(curQuiz);
  }

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;

    // chapter split
    const mCh = reChapter.exec(line);
    if (mCh && splitByChapter) {
      flushQuizIfHasQuestions();
      const chapNum = mCh[1];
      const chapName = (mCh[2] || '').trim();
      curQuiz = newQuiz(`Ch∆∞∆°ng ${chapNum}${chapName ? ': ' + chapName : ''}`);
      continue;
    }

    // question start
    const mQ = reQStart.exec(line);
    if (mQ) {
      flushQuestion();
      const qno = Number(mQ[1]);
      curQ = {
        _qno: Number.isFinite(qno) ? qno : null,
        text: mQ[2].trim(),
        choices: [],
        answer: null,          // number | number[] | null
        explanation: ''
      };
      pendingExplain = [];
      continue;
    }

    if (!curQ) continue;

    // choice
    const mC = reChoice.exec(line);
    if (mC) {
      curQ.choices.push(mC[2].trim());
      continue;
    }

    // answer line (explicit)
    const mA = reAnswer.exec(line);
    if (mA) {
      const rawAns = mA[1].toUpperCase().trim();
      curQ._rawAnswer = rawAns;
      const ans = normalizeAnswerRaw(rawAns);
      if (ans != null) curQ.answer = ans;
      continue;
    }

    // explanation
    const mE = reExplain.exec(line);
    if (mE) {
      const rest = (mE[1] || '').trim();
      if (rest) pendingExplain.push(rest);
      continue;
    }

    // other lines: append to question text if no choices yet; else to explanation
    if (curQ.choices.length === 0 && curQ.text) {
      curQ.text += '\n' + line;
    } else {
      pendingExplain.push(line);
    }
  }

  flushQuizIfHasQuestions();

  // Assign stable ids
  let runningId = 0;
  quizzes.forEach(qz => qz.questions.forEach(q => { if (q._id == null) q._id = runningId++; }));

  // -------------------------
  // PASS 2: If many answers missing, try to parse answer key at end: "1.A 2.B ..." / "1-A 2-C ..."
  // -------------------------
  const allQuestions = quizzes.flatMap(qz => qz.questions);
  const missing = allQuestions.filter(q => q.answer == null).length;

  if (missing > 0) {
    const ansMap = extractAnswerKeyFromTail(lines);
    if (ansMap.size) {
      for (const q of allQuestions) {
        if (q.answer != null) continue;
        if (q._qno == null) continue;
        const raw = ansMap.get(q._qno);
        if (!raw) continue;
        const ans = normalizeAnswerRaw(raw);
        if (ans != null) q.answer = ans;
      }
    }
  }

  // Finalize: for any still-missing answer, set 0 so app works (but mark in explanation)
  for (const q of allQuestions) {
    if (q.answer == null) {
      if (keepAnswerInExplanation) {
        q.explanation = (q.explanation ? (q.explanation + '\n') : '') + '‚ö†Ô∏è Thi·∫øu ƒë√°p √°n: m·∫∑c ƒë·ªãnh ch·∫•m A.';
      }
      q.answer = 0;
    }
  }

  // cleanup internal fields
  quizzes.forEach(qz => qz.questions.forEach(q => { delete q._qno; }));

  return quizzes;

  // ---- helper: extract answer key from tail ----
  function extractAnswerKeyFromTail(linesArr) {
    const map = new Map(); // qno -> "A" or "A,B"
    const maxScan = 250;   // scan up to last 250 non-empty lines
    let scanned = 0;
    let foundAny = false;

    // regex finds multiple pairs per line
    const pairRe = /(\d{1,4})\s*[\.\-\)\:\s]\s*([A-D])\b/gi;

    for (let i = linesArr.length - 1; i >= 0 && scanned < maxScan; i--) {
      const ln = String(linesArr[i] || '').trim();
      if (!ln) continue;
      scanned++;

      let m;
      let localCount = 0;
      pairRe.lastIndex = 0;
      while ((m = pairRe.exec(ln)) !== null) {
        const qno = Number(m[1]);
        const letter = m[2].toUpperCase();
        if (!Number.isFinite(qno)) continue;
        // accumulate if repeated => multi-answer (rare, but support)
        const prev = map.get(qno);
        map.set(qno, prev ? `${prev},${letter}` : letter);
        localCount++;
      }

      if (localCount >= 3) foundAny = true;

      // Heuristic stop: once we've found a dense block and then encounter a line with no pairs, stop scanning
      if (foundAny && localCount === 0) break;
    }

    return map;
  }
}

    function importerParse() {
      const raw = $('#textbookArea').value || '';
      if (!raw.trim()) {
        $('#importerReport').textContent = '‚ùå Ch∆∞a c√≥ n·ªôi dung ƒë·ªÉ parse.';
        return;
      }

      const splitByChapter = $('#splitByChapter').checked;
      const keepAnswerInExplanation = $('#keepAnswerInExplanation').checked;

      const quizzes = parseTextbookToQuizzes(raw, { splitByChapter, keepAnswerInExplanation });

      if (!quizzes.length) {
        __generatedQuizzes = null;
        $('#btnDownloadGenerated').disabled = true;
        $('#importerReport').textContent =
          '‚ùå Kh√¥ng parse ƒë∆∞·ª£c c√¢u h·ªèi. G·ª£i √Ω: ƒë·∫£m b·∫£o c√≥ d·∫°ng "1) ...", l·ª±a ch·ªçn "A. ...", v√† d√≤ng "ƒê√°p √°n: B".';
        return;
      }

      __generatedQuizzes = quizzes;
      $('#btnDownloadGenerated').disabled = false;

      const totalQ = quizzes.reduce((s, qz) => s + (qz.questions?.length || 0), 0);
      const titles = quizzes.slice(0, 5).map(qz => `‚Ä¢ ${qz.title} (${qz.questions.length} c√¢u)`).join('\n');
      $('#importerReport').textContent =
        `‚úÖ T·∫°o ƒë∆∞·ª£c ${quizzes.length} b·ªô / ${totalQ} c√¢u.\n${titles}${quizzes.length>5 ? '\n‚Ä¢ ...' : ''}\n\n` +
        `B·∫°n c√≥ th·ªÉ "T·∫£i JSON" ho·∫∑c n·∫°p th·∫≥ng v√†o app ƒë·ªÉ l√†m b√†i.`;

      if ($('#autoLoadAfterParse').checked) {
        handleData(quizzes);
        closeTextbookImporter();
        $('#statusMessage').innerHTML =
          `ƒê√£ t·∫°o t·ª´ gi√°o tr√¨nh: <b>${sanitizeHTML(quizzes[0]?.title || 'B·ªô c√¢u h·ªèi')}</b>. B·∫•m B·∫Øt ƒë·∫ßu ngay!`;
      }
    }

    function downloadGeneratedJSON() {
      if (!__generatedQuizzes) return;
      const blob = new Blob([JSON.stringify(__generatedQuizzes, null, 2)], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'generated-quiz.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 500);
    }

    // ===== SEARCH INDEX (pre-strip 1 l·∫ßn khi n·∫°p JSON) =====
let searchIndex = []; 
// searchIndex[qz] = { titleN: "...", q: [ { textN:"", choicesN:[...], expN:"" } ] }

function buildSearchIndex(quizzes) {
  searchIndex = quizzes.map(qz => ({
    titleN: strip(qz.title || ''),
    q: (qz.questions || []).map(qq => ({
      textN: strip(qq.text || ''),
      choicesN: (qq.choices || []).map(c => strip(c || '')),
      expN: strip(qq.explanation || '')
    }))
  }));
}
function questionMatches(qzIndex, i) {
  const k = searchKeywordN; // ‚úÖ ƒë√£ strip s·∫µn
  if (!k) return true;

  const qi = searchIndex[qzIndex]?.q?.[i];
  if (!qi) return true;

  return (
    qi.textN.includes(k) ||
    qi.expN.includes(k) ||
    qi.choicesN.some(x => x.includes(k))
  );
}

    // ===== MATHJAX OPTIMIZED RENDER (WAIT STARTUP) =====
let mathRenderTimer = null;
let mathTypesetChain = Promise.resolve(); // kh√≥a h√†ng ƒë·ª£i typeset

function toMathTargets(target) {
  if (!target) return [];
  return Array.isArray(target) ? target.filter(Boolean) : [target];
}

function whenMathJaxReady() {
  if (!window.MathJax) return Promise.resolve();
  if (MathJax.startup && MathJax.startup.promise) return MathJax.startup.promise;
  return Promise.resolve();
}

function renderMath(target) {
  if (!window.MathJax) return;
  const els = toMathTargets(target);
  if (!els.length) return;

  mathTypesetChain = mathTypesetChain
    .then(() => whenMathJaxReady())
    .then(() => MathJax.typesetPromise(els))
    .catch(() => {});
}

function renderMathDebounced(target, delay = 50) {
  if (!window.MathJax) return;
  const els = toMathTargets(target);
  if (!els.length) return;

  clearTimeout(mathRenderTimer);
  mathRenderTimer = setTimeout(() => {
    // serialize ƒë·ªÉ kh√¥ng typeset ch·ªìng l√™n nhau
    mathTypesetChain = mathTypesetChain
      .then(() => whenMathJaxReady())
      .then(() => MathJax.typesetPromise(els))
      .catch(() => {});
  }, delay);
}
function typesetAndThen(targets, done) {
  if (!window.MathJax) { done?.(); return; }
  const els = toMathTargets(targets);
  if (!els.length) { done?.(); return; }

  mathTypesetChain = mathTypesetChain
    .then(() => whenMathJaxReady())
    .then(() => MathJax.typesetPromise(els))
    .catch(() => {})
    .finally(() => done?.());
}

const API_BASE = "https://quizct11.onrender.com";

// ---- AI Explain cache & prefetch ----
const aiExplainCache = new Map();   // key -> { html, raw, ts }
const aiExplainInflight = new Map();// key -> Promise

function aiCacheKey(q, userAns) {
  const qid = (q && (q._id ?? q.id ?? q.qid ?? '')) + '';
  const ua = Array.isArray(userAns) ? userAns.slice().sort((a,b)=>a-b).join(',') : String(userAns ?? '');
  return `${qid}|${ua}`;
}

function normalizeUserAnswerForAI(userAns) {
  if (Array.isArray(userAns)) return userAns.slice().sort((a,b)=>a-b);
  return (userAns ?? null);
}

function fetchWithTimeout(url, opts = {}, timeoutMs = 12000) {
  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);
  return fetch(url, { ...opts, signal: ctrl.signal }).finally(() => clearTimeout(t));
}

// Attempt to stream text if server supports it; fallback to JSON
async function fetchAIExplain({ q, userAnsIndex, correctAnsIndex, onChunk, timeoutMs = 12000 }) {
  const payload = {
    question: q.text,
    choices: q.choices,
    userAnswerIndex: normalizeUserAnswerForAI(userAnsIndex),
    correctAnswerIndex: correctAnsIndex,
    teacherExplanation: q.explanation || '' 
  };

  const res = await fetchWithTimeout(`${API_BASE}/api/explain`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // Hint streaming if backend supports it (safe even if ignored)
      'Accept': 'text/plain, text/event-stream, application/json'
    },
    body: JSON.stringify(payload)
  }, timeoutMs);

  if (!res.ok) throw new Error(`HTTP ${res.status}`);

  const ct = (res.headers.get('content-type') || '').toLowerCase();

  // If JSON => standard response
  if (ct.includes('application/json')) {
    const data = await res.json();
    return String(data.explanation || '');
  }

  // Otherwise, treat as stream/text
  if (!res.body || !onChunk) {
    const t = await res.text();
    return String(t || '');
  }

  const reader = res.body.getReader();
  const decoder = new TextDecoder('utf-8');
  let full = '';
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    const chunk = decoder.decode(value, { stream: true });
    full += chunk;
    onChunk(chunk, full);
  }
  return full;
}

function renderAIBox(htmlOrText, { streaming = false } = {}) {
  const box = $('#explain');
  if (streaming) {
    // streaming: update progressively, do NOT typeset every chunk too aggressively
    box.innerHTML = `<b>AI gi·∫£i th√≠ch:</b><br>${sanitizeHTML(htmlOrText)}`;
  } else {
    box.innerHTML = `<b>AI gi·∫£i th√≠ch:</b><br>${sanitizeHTML(htmlOrText)}`;
    renderMathDebounced(box, 60);
  }
}

async function getAIExplainCached(q, userAnsIndex, correctAnsIndex, { streamToBox = false } = {}) {
  const key = aiCacheKey(q, userAnsIndex);

  if (aiExplainCache.has(key)) {
    return aiExplainCache.get(key).raw;
  }
  if (aiExplainInflight.has(key)) {
    return aiExplainInflight.get(key);
  }

  const p = (async () => {
    const raw = await fetchAIExplain({
      q,
      userAnsIndex,
      correctAnsIndex,
      onChunk: streamToBox ? (chunk, full) => {
        renderAIBox(full, { streaming: true });
      } : null
    });
    aiExplainCache.set(key, { raw, ts: Date.now() });
    return raw;
  })().finally(() => {
    aiExplainInflight.delete(key);
  });

  aiExplainInflight.set(key, p);
  return p;
}

// Prefetch (silent)
function prefetchAIExplain(q, userAnsIndex) {
  if (!q || !quiz) return;
  const correctAnsIndex = q.answer;
  // Don't stream during prefetch
  getAIExplainCached(q, userAnsIndex, correctAnsIndex, { streamToBox: false }).catch(() => {});
}

$('#btnAIExplain').onclick = async () => {
  const btn = $('#btnAIExplain');
  if (!quiz) return;

  const q = quiz.questions[idx];
  const userAnsIndex = answers[idx]?.value ?? null;
  const correctAnsIndex = q.answer;

  // immediate cache hit => instant UI
  const key = aiCacheKey(q, userAnsIndex);
  if (aiExplainCache.has(key)) {
    renderAIBox(aiExplainCache.get(key).raw, { streaming: false });
    return;
  }

  const old = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'ƒêang h·ªèi AI...';
  $('#explain').textContent = '‚è≥ ƒêang t·∫£i gi·∫£i th√≠ch...';

  try {
    // Streaming UI if backend supports streaming; else fallback to JSON
    const raw = await getAIExplainCached(q, userAnsIndex, correctAnsIndex, { streamToBox: true });
    // final render + MathJax (m∆∞·ª£t h∆°n)
    renderAIBox(raw, { streaming: false });
  } catch (e) {
    $('#explain').textContent = '‚ùå L·ªói khi g·ªçi AI: ' + (e?.message || e);
  } finally {
    btn.disabled = false;
    btn.textContent = old;
  }
};
    let allQuizzes = [], quiz = null, idx = 0, answers = [], timerId = null, wrongStreak = 0;
    let questionFilter = 'all'; // all | bookmark | wrong
    let autoNextTimer = null;
    // ===== EXAM GENERATOR (T·∫°o ƒë·ªÅ thi tr·ªôn ch∆∞∆°ng) =====
const EXAM_TITLE_PREFIX = "üìù ƒê·ªÅ thi ng·∫´u nhi√™n";

function clampInt(n, min, max) {
  n = Number(n);
  if (!Number.isFinite(n)) n = min;
  return Math.max(min, Math.min(max, Math.round(n)));
}

function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = (Math.random() * (i + 1)) | 0;
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function pickRandom(arr, k) {
  const copy = arr.slice();
  shuffleInPlace(copy);
  return copy.slice(0, Math.max(0, Math.min(k, copy.length)));
}

/**
 * T·∫°o quiz m·ªõi t·ª´ 3 ch∆∞∆°ng (allQuizzes[0..2]) theo % v√† t·ªïng c√¢u.
 * Kh√¥ng ƒë·ª•ng v√†o d·ªØ li·ªáu g·ªëc.
 */
function createExamQuiz({ total = 60, percents = [10,45,45] } = {}) {
  if (!Array.isArray(allQuizzes) || allQuizzes.length < 1) {
    throw new Error("Ch∆∞a c√≥ d·ªØ li·ªáu quiz.");
  }

  // M·∫∑c ƒë·ªãnh l·∫•y 3 ch∆∞∆°ng ƒë·∫ßu n·∫øu c√≥
  const chapters = [0,1,2].filter(i => allQuizzes[i] && Array.isArray(allQuizzes[i].questions));
  if (chapters.length === 0) throw new Error("Kh√¥ng t√¨m th·∫•y chapters/questions trong data.json.");

  total = clampInt(total, 1, 5000);

  // Chu·∫©n ho√° % theo s·ªë ch∆∞∆°ng th·ª±c c√≥
  const p = percents.slice(0, chapters.length).map(x => Math.max(0, Number(x) || 0));
  let sumP = p.reduce((a,b)=>a+b,0);
  if (sumP <= 0) {
    // n·∫øu user nh·∫≠p to√†n 0 -> chia ƒë·ªÅu
    for (let i=0;i<p.length;i++) p[i] = 100 / p.length;
    sumP = 100;
  }

  // target count theo %
  const target = p.map(pi => Math.floor((pi / sumP) * total));
  // b√π ph·∫ßn d∆∞ ƒë·ªÉ ƒë·ªß total
  let used = target.reduce((a,b)=>a+b,0);
  let remain = total - used;

  // danh s√°ch s·ªë c√¢u c√≤n c√≥ th·ªÉ l·∫•y ·ªü t·ª´ng ch∆∞∆°ng
  const cap = chapters.map((ci, idxLocal) => (allQuizzes[ci].questions || []).length);

  // b√π remain v√†o ch∆∞∆°ng c√≤n "d∆∞" nhi·ªÅu
  while (remain > 0) {
    let best = -1;
    let bestSlack = -1;
    for (let i=0;i<target.length;i++) {
      const slack = cap[i] - target[i];
      if (slack > bestSlack) { bestSlack = slack; best = i; }
    }
    if (best === -1 || bestSlack <= 0) break; // kh√¥ng c√≤n ƒë·ªß c√¢u ƒë·ªÉ b√π
    target[best]++;
    remain--;
  }

  // L·∫•y c√¢u
  let picked = [];
  for (let i=0;i<chapters.length;i++) {
    const ci = chapters[i];
    const qs = allQuizzes[ci].questions || [];
    const k = Math.min(target[i], qs.length);
    picked = picked.concat(pickRandom(qs, k));
  }

  // N·∫øu v·∫´n thi·∫øu (do ch∆∞∆°ng kh√¥ng ƒë·ªß), top-up t·ª´ t·∫•t c·∫£ ch∆∞∆°ng
  if (picked.length < total) {
    const pool = chapters.flatMap(ci => allQuizzes[ci].questions || []);
    // lo·∫°i tr√πng b·∫±ng _id/text (nh·∫π nh√†ng)
    const key = (q)=> (q._id ?? "") + "|" + (q.text ?? "");
    const seen = new Set(picked.map(key));
    const rest = pool.filter(q => !seen.has(key(q)));
    picked = picked.concat(pickRandom(rest, total - picked.length));
  }

  // Shuffle to√†n ƒë·ªÅ ƒë·ªÉ tr·ªôn ch∆∞∆°ng
  shuffleInPlace(picked);

  // t·∫°o quiz m·ªõi
  const title = `${EXAM_TITLE_PREFIX} (${picked.length} c√¢u)`;
  return {
    title,
    timeLimit: 0, // b·∫°n c√≥ th·ªÉ set theo √Ω
    questions: picked.map((q, i) => ({
      ...q,
      _id: q._id ?? i
    }))
  };
}

function upsertExamIntoAllQuizzes(examQuiz) {
  // N·∫øu ƒë√£ c√≥ "ƒê·ªÅ thi ng·∫´u nhi√™n" th√¨ replace, kh√¥ng nh√¢n b·∫£n
  const idxExist = allQuizzes.findIndex(q => (q?.title || "").startsWith(EXAM_TITLE_PREFIX));
  if (idxExist >= 0) allQuizzes[idxExist] = examQuiz;
  else allQuizzes.unshift(examQuiz); // ƒë·∫©y l√™n ƒë·∫ßu cho d·ªÖ ch·ªçn

  // rebuild search index + dropdown
  buildSearchIndex(allQuizzes);

  $('#quizSelectGroup').style.display = 'grid';
  $('#quizSelect').innerHTML = allQuizzes
    .map((q, i) => `<option value="${i}">${q.title || ('ƒê·ªÅ '+(i+1))}</option>`)
    .join('');
}
    const STORAGE_KEY = "shimechamhoc_progress_v1";
    let currentTimeLeft = 0;
    function handleData(data) {
      allQuizzes = Array.isArray(data) ? data : [data];
      buildSearchIndex(allQuizzes);
      if (allQuizzes.length > 1) {
        $('#quizSelectGroup').style.display = 'grid';
        $('#quizSelect').innerHTML = allQuizzes.map((q, i) => `<option value="${i}">${q.title || 'ƒê·ªÅ '+(i+1)}</option>`).join('');
      }
      setupQuiz(0);
    }
    function setupQuiz(index) {
      currentQuizIndex = Number(index) || 0;
  quiz = (window.structuredClone
    ? structuredClone(allQuizzes[index])
    : JSON.parse(JSON.stringify(allQuizzes[index]))
  );
  quiz.questions.forEach((q, i) => {
    if (q._id == null) q._id = i;
  });
  $('#timeLimit').value = Math.round((quiz.timeLimit||0)/60);
  $('#statusMessage').innerHTML =
  `ƒê√£ n·∫°p: <b>${sanitizeHTML(quiz.title || '')}</b>. B·∫•m B·∫Øt ƒë·∫ßu ngay!`;
}
    $('#quizSelect').onchange = (e) => setupQuiz(e.target.value);

    window.addEventListener('DOMContentLoaded', () => {
  fetch('data.json')
    .then(r => r.json())
    .then(data => {
      handleData(data);

      const saved = loadProgress();
      if (saved && confirm("üîÑ Ph√°t hi·ªán b√†i l√†m ch∆∞a ho√†n th√†nh. Ti·∫øp t·ª•c kh√¥ng?")) {
        quiz = saved.quiz;
        idx = saved.idx;
        answers = saved.answers;
        if (!Array.isArray(answers) || answers.length !== quiz.questions.length) {
  answers = quiz.questions.map(() => ({ value: null }));
}

        currentTimeLeft = saved.timeLeft;

        $('#instant').checked = saved.settings.instant;
        $('#autoNext').checked = saved.settings.autoNext;
        $('#shuffle').checked = saved.settings.shuffle;

        $('#screenIntro').style.display='none';
        $('#screenQuiz').style.display='block';
        mapBuilt = false;
        qCells = [];
        currentCellIndex = -1;
        buildQuestionMapOnce();
        renderQuestion();

        if (currentTimeLeft > 0) {
          if (timerId) clearInterval(timerId);

          timerId = setInterval(() => {
            currentTimeLeft--;
            saveProgressDebounced();

            let m = Math.floor(currentTimeLeft / 60);
            let s = (currentTimeLeft % 60).toString().padStart(2,'0');
            $('#timer').textContent = `${m}:${s}`;

            if(currentTimeLeft <= 0) {
              clearInterval(timerId);
              $('#btnSubmit').click();
            }
          }, 1000);
        } else {
          $('#timer').textContent = '‚àû';
        }
      } else {
        localStorage.removeItem(STORAGE_KEY);
      }
    })
    .catch(() => $('#statusMessage').textContent = "H√£y n·∫°p file JSON.");
});

    $('#fileInput').onchange = (e) => {
      const r = new FileReader();
      r.onload = () => { try { handleData(JSON.parse(r.result)); } catch(err) { alert('File kh√¥ng h·ª£p l·ªá!'); } };
      r.readAsText(e.target.files[0]);
    };
    function saveProgress() {
  if (!quiz || !answers.length) return;

  const data = {
    quiz,
    idx,
    answers,
    timeLeft: currentTimeLeft,
    settings: {
      instant: $('#instant').checked,
      autoNext: $('#autoNext').checked,
      shuffle: $('#shuffle').checked
    }
  };

  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
}

// Gi·∫£m spam localStorage: gom nhi·ªÅu l·∫ßn g·ªçi saveProgress trong th·ªùi gian ng·∫Øn
const saveProgressDebounced = (() => {
  let t = null;
  return () => {
    clearTimeout(t);
    t = setTimeout(() => {
      try { saveProgress(); } catch(e) {}
    }, 600);
  };
})();
function loadProgress() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return null;

  try {
    return JSON.parse(raw);
  } catch {
    localStorage.removeItem(STORAGE_KEY);
    return null;
  }
}
function buildQuestionMapOnce() {
  const grid = $('#questionGrid');
  if (!grid || mapBuilt || !quiz) return;

  grid.innerHTML = '';
  qCells = new Array(quiz.questions.length);

  quiz.questions.forEach((q, i) => {
    const cell = document.createElement('div');
    cell.className = 'qcell';
    cell.textContent = i + 1;
    cell.dataset.i = i;

    cell.onclick = () => {
      idx = i;
      renderQuestion();
      saveProgressDebounced();
    };

    grid.appendChild(cell);
    qCells[i] = cell;
  });

  mapBuilt = true;

  // c·∫≠p nh·∫≠t tr·∫°ng th√°i ban ƒë·∫ßu 1 l·∫ßn
  updateAllCells();
  updateCurrentCell();
  applyQuestionFilter(); // n·∫øu b·∫°n ƒëang ·ªü filter n√†o ƒë√≥
}

function updateCell(i) {
  const cell = qCells[i];
  if (!cell) return;

  const q = quiz.questions[i];
  const ans = answers[i]?.value ?? null;

  cell.classList.remove('done', 'correct', 'wrong', 'bookmark', 'current');

  if (ans !== null) cell.classList.add('done');
  if (q.bookmarked) cell.classList.add('bookmark');

  const canShowResult = $('#instant').checked || isSubmitted;
  if (canShowResult && ans !== null) {
    if (isAnswerCorrect(q, ans)) cell.classList.add('correct');
    else cell.classList.add('wrong');
  }
}

function updateAllCells() {
  for (let i = 0; i < qCells.length; i++) updateCell(i);
}

function updateCurrentCell() {
  // b·ªè current c≈©
  if (currentCellIndex >= 0 && qCells[currentCellIndex]) {
    qCells[currentCellIndex].classList.remove('current');
  }
  // set current m·ªõi
  currentCellIndex = idx;
  if (qCells[currentCellIndex]) qCells[currentCellIndex].classList.add('current');
}

// Filter ch·ªâ scan 1 l·∫ßn khi b·∫•m filter, KH√îNG scan m·ªói l·∫ßn click ƒë√°p √°n
function applyQuestionFilter() {
  if (!mapBuilt) return;

  for (let i = 0; i < quiz.questions.length; i++) {
    const q = quiz.questions[i];
    const ans = answers[i]?.value ?? null;

    let show = true;

    if (questionFilter === 'bookmark') {
      show = !!q.bookmarked;
    } else if (questionFilter === 'wrong') {
      const canShowWrong = $('#instant').checked || isSubmitted;
      show = (ans !== null) && canShowWrong && (ans !== q.answer);
    }
    if (show && searchKeywordN) {
  show = questionMatches(currentQuizIndex, i);
}
    qCells[i].style.display = show ? '' : 'none';
  }
}

// ---- Answer helpers (single & multi) ----
function asArrayAnswer(ans) {
  if (Array.isArray(ans)) return ans.slice().map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
  if (typeof ans === 'number' && Number.isFinite(ans)) return [ans];
  return [];
}
function asArrayUserAns(v) {
  if (Array.isArray(v)) return v.slice().map(Number).filter(Number.isFinite).sort((a,b)=>a-b);
  if (typeof v === 'number' && Number.isFinite(v)) return [v];
  return [];
}
function isAnswerCorrect(q, userVal) {
  const a = asArrayAnswer(q.answer);
  const u = asArrayUserAns(userVal);
  if (!a.length) return false;
  if (a.length !== u.length) return false;
  for (let i=0;i<a.length;i++) if (a[i] !== u[i]) return false;
  return true;
}
function isChoiceCorrect(q, choiceIndex) {
  return asArrayAnswer(q.answer).includes(choiceIndex);
}
// ===== UPDATE UI CHO CHOICES (KH√îNG RERENDER) =====
function applyChoiceUI() {
  const q = quiz.questions[idx];
  const selected = answers[idx]?.value ?? null;

  const selectedArr = asArrayUserAns(selected);
  const nodes = Array.from($('#qChoices').children);

  nodes.forEach((node, i) => {
    node.classList.remove('active', 'correct', 'wrong');

    // update input checked (radio/checkbox)
    const input = node.querySelector('input');
    if (input) input.checked = selectedArr.includes(i);

    // active styling
    if (selectedArr.includes(i)) node.classList.add('active');

    // instant grading
    const canShowResult = $('#instant').checked || isSubmitted;
    if (selectedArr.length && canShowResult) {
      if (isChoiceCorrect(q, i)) {
        node.classList.add('correct');
      } else if (selectedArr.includes(i)) {
        node.classList.add('wrong');
      }
    }
  });
}
function selectChoice(choiceIndex) {
  const q = quiz.questions[idx];
  if (!answers[idx]) answers[idx] = { value: null };

  const isMulti = Array.isArray(q.answer);

  if (!isMulti) {
    answers[idx].value = choiceIndex;
  } else {
    const cur = asArrayUserAns(answers[idx].value);
    const pos = cur.indexOf(choiceIndex);
    if (pos >= 0) cur.splice(pos, 1);
    else cur.push(choiceIndex);
    cur.sort((a,b)=>a-b);
    answers[idx].value = cur.length ? cur : null;
  }

  applyChoiceUI();

  // update map cell + save
  if (mapBuilt) {
    updateCell(idx);
    applyQuestionFilter();
  }

  saveProgressDebounced();

  // Prefetch AI silently (especially useful in instant-mode / wrong answers)
  try {
    const userVal = answers[idx].value;
    const instant = $('#instant').checked;
    if (instant) {
      // prioritize prefetch when user seems wrong
      if (!isAnswerCorrect(q, userVal)) prefetchAIExplain(q, userVal);
    } else {
      // light prefetch anyway
      prefetchAIExplain(q, userVal);
    }
  } catch {}

  // instant explanation text (local)
  const canShowResult = $('#instant').checked || isSubmitted;
  if (canShowResult && answers[idx].value !== null) {
    if (q.explanation) {
      $('#explain').textContent = "Gi·∫£i th√≠ch: " + q.explanation;
      renderMathDebounced($('#explain'), 50);
    }
  }

  // auto next (only for single-choice, otherwise user needs multi picks)
  if (!isMulti && $('#autoNext').checked && idx < quiz.questions.length - 1) {
    clearTimeout(autoNextTimer);
    const extra = 500;
    const delay = ($('#instant').checked ? 800 : 250) + extra;
    autoNextTimer = setTimeout(() => {
      idx++;
      renderQuestion();
      saveProgressDebounced();
    }, delay);
  }
}
    function renderQuestion() {
  const quizScreen = $('#screenQuiz');
  quizScreen.classList.add('is-switching');
  const q = quiz.questions[idx];
  if (!answers[idx]) answers[idx] = { value: null };
  if (q.bookmarked === undefined) q.bookmarked = false;

  $('#qIndex').textContent = `C√¢u ${idx+1}/${quiz.questions.length}`;

  const qTextEl = $('#qText');
  qTextEl.innerHTML = sanitizeHTML(q.text);

  const box = $('#qChoices');
  box.innerHTML = '';
  $('#explain').textContent = '';

  const isMulti = Array.isArray(q.answer);
  const inputType = isMulti ? 'checkbox' : 'radio';
  const inputName = 'opt';

  q.choices.forEach((c, i) => {
    const wrap = document.createElement('div');
    wrap.className = 'choice';
    wrap.dataset.choice = String(i);
    wrap.innerHTML = `
      <input type="${inputType}" name="${inputName}" style="margin-right:10px">
      <label style="cursor:pointer">${sanitizeHTML(c)}</label>
    `;
    box.appendChild(wrap);
  });

  // Event delegation: 1 listener
  box.onclick = (e) => {
    const node = e.target.closest('.choice');
    if (!node) return;
    const i = Number(node.dataset.choice);
    if (Number.isFinite(i)) selectChoice(i);
  };

  applyChoiceUI();

  typesetAndThen([qTextEl, box], () => {
    quizScreen.classList.remove('is-switching');
  });

  $('#btnPrev').disabled = (idx === 0);
  $('#btnNext').style.visibility = (idx === quiz.questions.length - 1) ? 'hidden' : 'visible';

  // bookmark icon
  buildQuestionMapOnce();
  updateCell(idx);
  updateCurrentCell();
  applyQuestionFilter();

  // ===== BOOKMARK UI =====
  const bm = $('#bookmarkBtn');
  bm.classList.toggle('active', q.bookmarked);
  bm.textContent = q.bookmarked ? '‚≠ê' : '‚òÜ';

  bm.onclick = () => {
    q.bookmarked = !q.bookmarked;
    bm.classList.toggle('active', q.bookmarked);
    bm.textContent = q.bookmarked ? '‚≠ê' : '‚òÜ';
    saveProgressDebounced();
    if (mapBuilt) {
      updateCell(idx);
      applyQuestionFilter();
    }
  };
}
    $('#btnNext').onclick = () => {
  if(idx < quiz.questions.length - 1) {
    idx++;
    renderQuestion();
    saveProgressDebounced();
  }
};

$('#btnPrev').onclick = () => {
  if(idx > 0) {
    idx--;
    renderQuestion();
    saveProgressDebounced();
  }
};


    $('#btnStart').onclick = () => {
  if(!quiz) return;
  if($('#shuffle').checked) shuffleInPlace(quiz.questions);
  answers = quiz.questions.map(() => ({value: null}));
  idx = 0;

  mapBuilt = false;
  qCells = [];
  currentCellIndex = -1;

  $('#screenIntro').style.display='none';
  $('#screenQuiz').style.display='block';

  buildQuestionMapOnce();
  renderQuestion();
  startTimer();
};

    function launchFireworks() {
  const canvas = document.getElementById("fireworks");
  const ctx = canvas.getContext("2d");

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  let particles = [];

  function boom(x) {
    for (let i = 0; i < 80; i++) {
      particles.push({
        x,
        y: canvas.height * 0.5,
        vx: Math.cos(Math.random() * Math.PI * 2) * (3 + Math.random() * 4),
        vy: Math.sin(Math.random() * Math.PI * 2) * (3 + Math.random() * 4),
        life: 60,
        color: `hsl(${Math.random() * 360},100%,60%)`
      });
    }
  }

  boom(canvas.width * 0.2);
  boom(canvas.width * 0.8);

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    particles.forEach((p, i) => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.05;
      p.life--;

      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
      ctx.fill();

      if (p.life <= 0) particles.splice(i, 1);
    });

    if (particles.length) requestAnimationFrame(animate);
  }

  animate();

  const text = document.getElementById("congratsText");
  text.classList.add("show");
  setTimeout(() => text.classList.remove("show"), 4000);
}
    $('#btnSubmit').onclick = () => {
       if(!confirm("B·∫°n mu·ªën n·ªôp b√†i?")) return;
      isSubmitted = true;
      if (mapBuilt) {
      updateAllCells();
      applyQuestionFilter();
      }
      localStorage.removeItem(STORAGE_KEY);
      clearInterval(timerId);
      
      let totalCorrect = 0;
      quiz.questions.forEach((q, i) => {
        const userVal = answers[i]?.value ?? null;
        if (userVal !== null && isAnswerCorrect(q, userVal)) totalCorrect++;
      });
const total = quiz.questions.length;
      const percent = Math.round((totalCorrect / total) * 100);
      $('#scoreLine').textContent = `K·∫øt qu·∫£: ${totalCorrect}/${total} c√¢u ƒë√∫ng (${percent}%)`;
      $('#scoreBar').style.width = percent + '%';
      $('#screenQuiz').style.display='none'; 
      $('#screenResult').style.display='block';
      $('#resultOverlay').classList.add('show');
      $('#congratsText').classList.add('show');
      setTimeout(() => {
      $('#resultOverlay').classList.remove('show');
      $('#congratsText').classList.remove('show');
}, 2500);

      
      generateReview();
      launchFireworks();

    };

    function generateReview() {
  const area = $('#reviewArea');
  area.innerHTML = '<h3 style="margin-top:30px">Chi ti·∫øt b√†i l√†m:</h3>';

  const fmt = (q, val) => {
    const arr = asArrayUserAns(val);
    if (!arr.length) return 'Ch∆∞a tr·∫£ l·ªùi';
    return arr.map(i => sanitizeHTML(q.choices[i] ?? `(${i})`)).join(' | ');
  };
  const fmtCorrect = (q) => {
    const arr = asArrayAnswer(q.answer);
    return arr.map(i => sanitizeHTML(q.choices[i] ?? `(${i})`)).join(' | ');
  };

  quiz.questions.forEach((q, i) => {
    const userAns = answers[i]?.value ?? null;
    const ok = isAnswerCorrect(q, userAns);

    const card = document.createElement('div');
    card.className = 'card pad';
    card.style.marginBottom = '15px';
    card.style.borderLeft = `5px solid ${ok ? 'var(--ok)' : 'var(--bad)'}`;

    card.innerHTML = `
      <div style="font-weight:800; margin-bottom:5px">
        C√¢u ${i+1}: ${sanitizeHTML(q.text)}
      </div>
      <div style="color:${ok ? 'var(--ok)' : 'var(--bad)'}">
        <div><b>B·∫°n ch·ªçn:</b> ${fmt(q, userAns)}</div>
        <div><b>ƒê√°p √°n ƒë√∫ng:</b> ${fmtCorrect(q)}</div>
      </div>
      ${q.explanation ? `<div class="muted" style="margin-top:5px; font-size:13px">${sanitizeHTML(q.explanation)}</div>` : ``}
    `;
    area.appendChild(card);
  });

  renderMathDebounced(area, 80);
}
    function startTimer(){
  if (timerId) clearInterval(timerId);

  currentTimeLeft = Number($('#timeLimit').value) * 60;
  if(currentTimeLeft <= 0) {
    $('#timer').textContent = '‚àû';
    return;
  }
  timerId = setInterval(() => {
    currentTimeLeft--;
    saveProgressDebounced();
    let m = Math.floor(currentTimeLeft / 60);
    let s = (currentTimeLeft % 60).toString().padStart(2,'0');
    $('#timer').textContent = `${m}:${s}`;
    if(currentTimeLeft <= 0) {
      clearInterval(timerId);
      $('#btnSubmit').click();
    }
  }, 1000);
}
    // ===== THEME TOGGLE =====
const themeBtn = document.getElementById('toggleTheme');

function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  localStorage.setItem('theme', theme);
}
function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme') || 'dark';
  setTheme(current === 'dark' ? 'light' : 'dark');
}
// Load theme khi m·ªü trang
const savedTheme = localStorage.getItem('theme') || 'dark';
setTheme(savedTheme);
// Click n√∫t
themeBtn.onclick = toggleTheme;
$('#filterAll').onclick = () => {
  questionFilter = 'all';
  applyQuestionFilter();
};
$('#filterBookmark').onclick = () => {
  questionFilter = 'bookmark';
  applyQuestionFilter();
};
$('#filterWrong').onclick = () => {
  questionFilter = 'wrong';
  applyQuestionFilter();
};
$('#searchBox').oninput = (e) => {
  searchKeywordN = strip(e.target.value); // keyword ƒë√£ strip s·∫µn
  applyQuestionFilter();
};
// ===== Button: T·∫°o ƒë·ªÅ thi =====
$('#btnMakeExam').onclick = () => {
  try {
    const total = clampInt($('#examCount').value, 10, 2000);
    const p1 = clampInt($('#p1').value, 0, 100);
    const p2 = clampInt($('#p2').value, 0, 100);
    const p3 = clampInt($('#p3').value, 0, 100);

    const examQuiz = createExamQuiz({
      total,
      percents: [p1, p2, p3]
    });

    upsertExamIntoAllQuizzes(examQuiz);
    // chuy·ªÉn sang quiz ƒë·ªÅ thi v·ª´a t·∫°o
    $('#quizSelect').value = 0;
    setupQuiz(0);

    $('#examInfo').textContent = `‚úÖ ƒê√£ t·∫°o: ${examQuiz.title}. B·∫•m "B·∫Øt ƒë·∫ßu" ƒë·ªÉ l√†m.`;
  } catch (e) {
    $('#examInfo').textContent = '‚ùå ' + (e?.message || e);
  }
};

  </script>
  <canvas id="fireworks"></canvas>
<div id="congratsText">üéâ Ch√∫c m·ª´ng b·∫°n ƒë√£ ho√†n th√†nh b√†i l√†m!</div>
<div id="resultOverlay"></div>
</body>
</html>